/* eslint-disable */
/*Generated by GenDocu.com*/
// package: mt4grpc
// file: mt4.proto

var mt4_pb = require("./mt4_pb");
var grpc = require("@improbable-eng/grpc-web").grpc;

var Connection = (function () {
  function Connection() {}
  Connection.serviceName = "mt4grpc.Connection";
  return Connection;
}());

Connection.Connect = {
  methodName: "Connect",
  service: Connection,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.ConnectRequest,
  responseType: mt4_pb.ConnectReply
};

Connection.CheckConnect = {
  methodName: "CheckConnect",
  service: Connection,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.CheckConnectRequest,
  responseType: mt4_pb.CheckConnectReply
};

Connection.Disconnect = {
  methodName: "Disconnect",
  service: Connection,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.DisconnectRequest,
  responseType: mt4_pb.DisconnectReply
};

exports.Connection = Connection;

function ConnectionClient(serviceHost, options) {
  this.serviceHost = serviceHost;
  this.options = options || {};
}

ConnectionClient.prototype.connect = function connect(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Connection.Connect, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ConnectionClient.prototype.checkConnect = function checkConnect(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Connection.CheckConnect, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ConnectionClient.prototype.disconnect = function disconnect(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Connection.Disconnect, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

exports.ConnectionClient = ConnectionClient;

var MT4 = (function () {
  function MT4() {}
  MT4.serviceName = "mt4grpc.MT4";
  return MT4;
}());

MT4.AccountSummary = {
  methodName: "AccountSummary",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.AccountSummaryRequest,
  responseType: mt4_pb.AccountSummaryReply
};

MT4.Groups = {
  methodName: "Groups",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.GroupsRequest,
  responseType: mt4_pb.GroupsReply
};

MT4.Quote = {
  methodName: "Quote",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.QuoteRequest,
  responseType: mt4_pb.QuoteReply
};

MT4.OpenedOrders = {
  methodName: "OpenedOrders",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OpenedOrdersRequest,
  responseType: mt4_pb.OpenedOrdersReply
};

MT4.Symbols = {
  methodName: "Symbols",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SymbolsRequest,
  responseType: mt4_pb.SymbolsReply
};

MT4.SymbolParams = {
  methodName: "SymbolParams",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SymbolParamsRequest,
  responseType: mt4_pb.SymbolParamsReply
};

MT4.ServerTimezone = {
  methodName: "ServerTimezone",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.ServerTimezoneRequest,
  responseType: mt4_pb.ServerTimezoneReply
};

MT4.SymbolParamsMany = {
  methodName: "SymbolParamsMany",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SymbolParamsManyRequest,
  responseType: mt4_pb.SymbolParamsManyReply
};

MT4.OpenedOrder = {
  methodName: "OpenedOrder",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OpenedOrderRequest,
  responseType: mt4_pb.OpenedOrderReply
};

MT4.OrderHistory = {
  methodName: "OrderHistory",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OrderHistoryRequest,
  responseType: mt4_pb.OrderHistoryReply
};

MT4.QuoteHistory = {
  methodName: "QuoteHistory",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.QuoteHistoryRequest,
  responseType: mt4_pb.QuoteHistoryReply
};

MT4.QuoteHistoryMany = {
  methodName: "QuoteHistoryMany",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.QuoteHistoryManyRequest,
  responseType: mt4_pb.QuoteHistoryManyReply
};

MT4.ClosedOrders = {
  methodName: "ClosedOrders",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.ClosedOrdersRequest,
  responseType: mt4_pb.ClosedOrdersReply
};

MT4.RequestQuoteHistory = {
  methodName: "RequestQuoteHistory",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.RequestQuoteHistoryRequest,
  responseType: mt4_pb.RequestQuoteHistoryReply
};

MT4.SetPlacedType = {
  methodName: "SetPlacedType",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SetPlacedTypeRequest,
  responseType: mt4_pb.SetPlacedTypeReply
};

MT4.IsInvestor = {
  methodName: "IsInvestor",
  service: MT4,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.IsInvestorRequest,
  responseType: mt4_pb.IsInvestorReply
};

exports.MT4 = MT4;

function MT4Client(serviceHost, options) {
  this.serviceHost = serviceHost;
  this.options = options || {};
}

MT4Client.prototype.accountSummary = function accountSummary(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.AccountSummary, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.groups = function groups(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.Groups, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.quote = function quote(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.Quote, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.openedOrders = function openedOrders(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.OpenedOrders, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.symbols = function symbols(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.Symbols, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.symbolParams = function symbolParams(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.SymbolParams, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.serverTimezone = function serverTimezone(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.ServerTimezone, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.symbolParamsMany = function symbolParamsMany(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.SymbolParamsMany, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.openedOrder = function openedOrder(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.OpenedOrder, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.orderHistory = function orderHistory(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.OrderHistory, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.quoteHistory = function quoteHistory(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.QuoteHistory, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.quoteHistoryMany = function quoteHistoryMany(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.QuoteHistoryMany, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.closedOrders = function closedOrders(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.ClosedOrders, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.requestQuoteHistory = function requestQuoteHistory(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.RequestQuoteHistory, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.setPlacedType = function setPlacedType(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.SetPlacedType, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

MT4Client.prototype.isInvestor = function isInvestor(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(MT4.IsInvestor, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

exports.MT4Client = MT4Client;

var Service = (function () {
  function Service() {}
  Service.serviceName = "mt4grpc.Service";
  return Service;
}());

Service.Ping = {
  methodName: "Ping",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.PingRequest,
  responseType: mt4_pb.PingReply
};

Service.GetLogs = {
  methodName: "GetLogs",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.GetLogsRequest,
  responseType: mt4_pb.GetLogsReply
};

Service.GetLogsByUser = {
  methodName: "GetLogsByUser",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.GetLogsByUserRequest,
  responseType: mt4_pb.GetLogsByUserReply
};

Service.MemorySnapshot = {
  methodName: "MemorySnapshot",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.MemorySnapshotRequest,
  responseType: mt4_pb.MemorySnapshotReply
};

Service.Search = {
  methodName: "Search",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SearchRequest,
  responseType: mt4_pb.SearchReply
};

Service.GetClients = {
  methodName: "GetClients",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.GetClientsRequest,
  responseType: mt4_pb.GetClientsReply
};

Service.MemoryUsage = {
  methodName: "MemoryUsage",
  service: Service,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.MemoryUsageRequest,
  responseType: mt4_pb.MemoryUsageReply
};

exports.Service = Service;

function ServiceClient(serviceHost, options) {
  this.serviceHost = serviceHost;
  this.options = options || {};
}

ServiceClient.prototype.ping = function ping(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.Ping, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ServiceClient.prototype.getLogs = function getLogs(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.GetLogs, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ServiceClient.prototype.getLogsByUser = function getLogsByUser(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.GetLogsByUser, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ServiceClient.prototype.memorySnapshot = function memorySnapshot(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.MemorySnapshot, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ServiceClient.prototype.search = function search(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.Search, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ServiceClient.prototype.getClients = function getClients(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.GetClients, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

ServiceClient.prototype.memoryUsage = function memoryUsage(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Service.MemoryUsage, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

exports.ServiceClient = ServiceClient;

var Subscriptions = (function () {
  function Subscriptions() {}
  Subscriptions.serviceName = "mt4grpc.Subscriptions";
  return Subscriptions;
}());

Subscriptions.Subscribe = {
  methodName: "Subscribe",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SubscribeRequest,
  responseType: mt4_pb.SubscribeReply
};

Subscriptions.SubscribeMany = {
  methodName: "SubscribeMany",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SubscribeManyRequest,
  responseType: mt4_pb.SubscribeManyReply
};

Subscriptions.UnSubscribe = {
  methodName: "UnSubscribe",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.UnSubscribeRequest,
  responseType: mt4_pb.UnSubscribeReply
};

Subscriptions.UnSubscribeMany = {
  methodName: "UnSubscribeMany",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.UnSubscribeManyRequest,
  responseType: mt4_pb.UnSubscribeManyReply
};

Subscriptions.SubscribeOrderProfit = {
  methodName: "SubscribeOrderProfit",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SubscribeOrderProfitRequest,
  responseType: mt4_pb.SubscribeOrderProfitReply
};

Subscriptions.SubscribeTickValue = {
  methodName: "SubscribeTickValue",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SubscribeTickValueRequest,
  responseType: mt4_pb.SubscribeTickValueReply
};

Subscriptions.SubscribeOrderUpdate = {
  methodName: "SubscribeOrderUpdate",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SubscribeOrderUpdateRequest,
  responseType: mt4_pb.SubscribeOrderUpdateReply
};

Subscriptions.SubscribeQuoteHistory = {
  methodName: "SubscribeQuoteHistory",
  service: Subscriptions,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.SubscribeQuoteHistoryRequest,
  responseType: mt4_pb.SubscribeQuoteHistoryReply
};

exports.Subscriptions = Subscriptions;

function SubscriptionsClient(serviceHost, options) {
  this.serviceHost = serviceHost;
  this.options = options || {};
}

SubscriptionsClient.prototype.subscribe = function subscribe(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.Subscribe, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.subscribeMany = function subscribeMany(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.SubscribeMany, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.unSubscribe = function unSubscribe(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.UnSubscribe, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.unSubscribeMany = function unSubscribeMany(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.UnSubscribeMany, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.subscribeOrderProfit = function subscribeOrderProfit(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.SubscribeOrderProfit, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.subscribeTickValue = function subscribeTickValue(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.SubscribeTickValue, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.subscribeOrderUpdate = function subscribeOrderUpdate(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.SubscribeOrderUpdate, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

SubscriptionsClient.prototype.subscribeQuoteHistory = function subscribeQuoteHistory(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Subscriptions.SubscribeQuoteHistory, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

exports.SubscriptionsClient = SubscriptionsClient;

var Trading = (function () {
  function Trading() {}
  Trading.serviceName = "mt4grpc.Trading";
  return Trading;
}());

Trading.OrderSend = {
  methodName: "OrderSend",
  service: Trading,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OrderSendRequest,
  responseType: mt4_pb.OrderSendReply
};

Trading.OrderModify = {
  methodName: "OrderModify",
  service: Trading,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OrderModifyRequest,
  responseType: mt4_pb.OrderModifyReply
};

Trading.OrderCloseBy = {
  methodName: "OrderCloseBy",
  service: Trading,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OrderCloseByRequest,
  responseType: mt4_pb.OrderCloseByReply
};

Trading.OrderDelete = {
  methodName: "OrderDelete",
  service: Trading,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OrderDeleteRequest,
  responseType: mt4_pb.OrderDeleteReply
};

Trading.OrderClose = {
  methodName: "OrderClose",
  service: Trading,
  requestStream: false,
  responseStream: false,
  requestType: mt4_pb.OrderCloseRequest,
  responseType: mt4_pb.OrderCloseReply
};

exports.Trading = Trading;

function TradingClient(serviceHost, options) {
  this.serviceHost = serviceHost;
  this.options = options || {};
}

TradingClient.prototype.orderSend = function orderSend(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Trading.OrderSend, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

TradingClient.prototype.orderModify = function orderModify(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Trading.OrderModify, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

TradingClient.prototype.orderCloseBy = function orderCloseBy(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Trading.OrderCloseBy, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

TradingClient.prototype.orderDelete = function orderDelete(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Trading.OrderDelete, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

TradingClient.prototype.orderClose = function orderClose(requestMessage, metadata, callback) {
  if (arguments.length === 2) {
    callback = arguments[1];
  }
  var client = grpc.unary(Trading.OrderClose, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onEnd: function (response) {
      if (callback) {
        if (response.status !== grpc.Code.OK) {
          var err = new Error(response.statusMessage);
          err.code = response.status;
          err.metadata = response.trailers;
          callback(err, null);
        } else {
          callback(null, response.message);
        }
      }
    }
  });
  return {
    cancel: function () {
      callback = null;
      client.close();
    }
  };
};

exports.TradingClient = TradingClient;

var Streams = (function () {
  function Streams() {}
  Streams.serviceName = "mt4grpc.Streams";
  return Streams;
}());

Streams.OnOrderUpdate = {
  methodName: "OnOrderUpdate",
  service: Streams,
  requestStream: false,
  responseStream: true,
  requestType: mt4_pb.OnOrderUpdateRequest,
  responseType: mt4_pb.OnOrderUpdateReply
};

Streams.OnQuote = {
  methodName: "OnQuote",
  service: Streams,
  requestStream: false,
  responseStream: true,
  requestType: mt4_pb.OnQuoteRequest,
  responseType: mt4_pb.OnQuoteReply
};

Streams.OnTickValue = {
  methodName: "OnTickValue",
  service: Streams,
  requestStream: false,
  responseStream: true,
  requestType: mt4_pb.OnTickValueRequest,
  responseType: mt4_pb.OnTickValueReply
};

Streams.OnOrderProfit = {
  methodName: "OnOrderProfit",
  service: Streams,
  requestStream: false,
  responseStream: true,
  requestType: mt4_pb.OnOrderProfitRequest,
  responseType: mt4_pb.OnOrderProfitReply
};

exports.Streams = Streams;

function StreamsClient(serviceHost, options) {
  this.serviceHost = serviceHost;
  this.options = options || {};
}

StreamsClient.prototype.onOrderUpdate = function onOrderUpdate(requestMessage, metadata) {
  var listeners = {
    data: [],
    end: [],
    status: []
  };
  var client = grpc.invoke(Streams.OnOrderUpdate, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onMessage: function (responseMessage) {
      listeners.data.forEach(function (handler) {
        handler(responseMessage);
      });
    },
    onEnd: function (status, statusMessage, trailers) {
      listeners.status.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners.end.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners = null;
    }
  });
  return {
    on: function (type, handler) {
      listeners[type].push(handler);
      return this;
    },
    cancel: function () {
      listeners = null;
      client.close();
    }
  };
};

StreamsClient.prototype.onQuote = function onQuote(requestMessage, metadata) {
  var listeners = {
    data: [],
    end: [],
    status: []
  };
  var client = grpc.invoke(Streams.OnQuote, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onMessage: function (responseMessage) {
      listeners.data.forEach(function (handler) {
        handler(responseMessage);
      });
    },
    onEnd: function (status, statusMessage, trailers) {
      listeners.status.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners.end.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners = null;
    }
  });
  return {
    on: function (type, handler) {
      listeners[type].push(handler);
      return this;
    },
    cancel: function () {
      listeners = null;
      client.close();
    }
  };
};

StreamsClient.prototype.onTickValue = function onTickValue(requestMessage, metadata) {
  var listeners = {
    data: [],
    end: [],
    status: []
  };
  var client = grpc.invoke(Streams.OnTickValue, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onMessage: function (responseMessage) {
      listeners.data.forEach(function (handler) {
        handler(responseMessage);
      });
    },
    onEnd: function (status, statusMessage, trailers) {
      listeners.status.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners.end.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners = null;
    }
  });
  return {
    on: function (type, handler) {
      listeners[type].push(handler);
      return this;
    },
    cancel: function () {
      listeners = null;
      client.close();
    }
  };
};

StreamsClient.prototype.onOrderProfit = function onOrderProfit(requestMessage, metadata) {
  var listeners = {
    data: [],
    end: [],
    status: []
  };
  var client = grpc.invoke(Streams.OnOrderProfit, {
    request: requestMessage,
    host: this.serviceHost,
    metadata: metadata,
    transport: this.options.transport,
    debug: this.options.debug,
    onMessage: function (responseMessage) {
      listeners.data.forEach(function (handler) {
        handler(responseMessage);
      });
    },
    onEnd: function (status, statusMessage, trailers) {
      listeners.status.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners.end.forEach(function (handler) {
        handler({ code: status, details: statusMessage, metadata: trailers });
      });
      listeners = null;
    }
  });
  return {
    on: function (type, handler) {
      listeners[type].push(handler);
      return this;
    },
    cancel: function () {
      listeners = null;
      client.close();
    }
  };
};

exports.StreamsClient = StreamsClient;

