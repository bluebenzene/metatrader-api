// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ConnectionClient is the client API for Connection service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectionClient interface {
	// Connect to account with user, password, host, port.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "user": "500476959", <br>
	//	 "password": "ehj4bod", <br>
	//	 "host": "mt4-demo.roboforex.com", <br>
	//	 "port": "443" <br>
	//	}
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectReply, error)
	// Check connection state and reconnect if connection lost
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	CheckConnect(ctx context.Context, in *CheckConnectRequest, opts ...grpc.CallOption) (*CheckConnectReply, error)
	// Disconnect from account
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectReply, error)
}

type connectionClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionClient(cc grpc.ClientConnInterface) ConnectionClient {
	return &connectionClient{cc}
}

func (c *connectionClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectReply, error) {
	out := new(ConnectReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Connection/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionClient) CheckConnect(ctx context.Context, in *CheckConnectRequest, opts ...grpc.CallOption) (*CheckConnectReply, error) {
	out := new(CheckConnectReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Connection/CheckConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectReply, error) {
	out := new(DisconnectReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Connection/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectionServer is the server API for Connection service.
// All implementations must embed UnimplementedConnectionServer
// for forward compatibility
type ConnectionServer interface {
	// Connect to account with user, password, host, port.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "user": "500476959", <br>
	//	 "password": "ehj4bod", <br>
	//	 "host": "mt4-demo.roboforex.com", <br>
	//	 "port": "443" <br>
	//	}
	Connect(context.Context, *ConnectRequest) (*ConnectReply, error)
	// Check connection state and reconnect if connection lost
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	CheckConnect(context.Context, *CheckConnectRequest) (*CheckConnectReply, error)
	// Disconnect from account
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectReply, error)
	mustEmbedUnimplementedConnectionServer()
}

// UnimplementedConnectionServer must be embedded to have forward compatible implementations.
type UnimplementedConnectionServer struct {
}

func (UnimplementedConnectionServer) Connect(context.Context, *ConnectRequest) (*ConnectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedConnectionServer) CheckConnect(context.Context, *CheckConnectRequest) (*CheckConnectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckConnect not implemented")
}
func (UnimplementedConnectionServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedConnectionServer) mustEmbedUnimplementedConnectionServer() {}

// UnsafeConnectionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionServer will
// result in compilation errors.
type UnsafeConnectionServer interface {
	mustEmbedUnimplementedConnectionServer()
}

func RegisterConnectionServer(s grpc.ServiceRegistrar, srv ConnectionServer) {
	s.RegisterService(&Connection_ServiceDesc, srv)
}

func _Connection_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Connection/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connection_CheckConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionServer).CheckConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Connection/CheckConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionServer).CheckConnect(ctx, req.(*CheckConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connection_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Connection/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Connection_ServiceDesc is the grpc.ServiceDesc for Connection service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Connection_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt4grpc.Connection",
	HandlerType: (*ConnectionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Connection_Connect_Handler,
		},
		{
			MethodName: "CheckConnect",
			Handler:    _Connection_CheckConnect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Connection_Disconnect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt4.proto",
}

// MT4Client is the client API for MT4 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MT4Client interface {
	// Balance, Equity, Currency, FreeMargin, Margin, MarginLevel, Profit, Leverage, Credit
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	AccountSummary(ctx context.Context, in *AccountSummaryRequest, opts ...grpc.CallOption) (*AccountSummaryReply, error)
	// Full infromation about symbol groups
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	Groups(ctx context.Context, in *GroupsRequest, opts ...grpc.CallOption) (*GroupsReply, error)
	// Get quote
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD" <br>
	//	}
	Quote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteReply, error)
	// List of opened orders
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OpenedOrders(ctx context.Context, in *OpenedOrdersRequest, opts ...grpc.CallOption) (*OpenedOrdersReply, error)
	// List of symbols.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	Symbols(ctx context.Context, in *SymbolsRequest, opts ...grpc.CallOption) (*SymbolsReply, error)
	// Full infromation about symbol and his group
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD" <br>
	//	}
	SymbolParams(ctx context.Context, in *SymbolParamsRequest, opts ...grpc.CallOption) (*SymbolParamsReply, error)
	// Server timezone.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	ServerTimezone(ctx context.Context, in *ServerTimezoneRequest, opts ...grpc.CallOption) (*ServerTimezoneReply, error)
	// Full infromation about symbols
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SymbolParamsMany(ctx context.Context, in *SymbolParamsManyRequest, opts ...grpc.CallOption) (*SymbolParamsManyReply, error)
	// List of opened orders
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0" <br>
	//	}
	OpenedOrder(ctx context.Context, in *OpenedOrderRequest, opts ...grpc.CallOption) (*OpenedOrderReply, error)
	// Order history
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "from": "2022-01-01T00:00:00", <br>
	//	 "to": "2023-06-01T00:00:00" <br>
	//	}
	OrderHistory(ctx context.Context, in *OrderHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryReply, error)
	// Price history.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "timeframe": "D1", <br>
	//	 "from": "2022-10-01T00:00:00", <br>
	//	 "count": "10" <br>
	//	}
	QuoteHistory(ctx context.Context, in *QuoteHistoryRequest, opts ...grpc.CallOption) (*QuoteHistoryReply, error)
	// Price history.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "timeframe": "D1", <br>
	//	 "from": "2022-10-01T00:00:00", <br>
	//	 "count": "10" <br>
	//	}
	QuoteHistoryMany(ctx context.Context, in *QuoteHistoryManyRequest, opts ...grpc.CallOption) (*QuoteHistoryManyReply, error)
	// Last 10 orders that were closed during current session
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	ClosedOrders(ctx context.Context, in *ClosedOrdersRequest, opts ...grpc.CallOption) (*ClosedOrdersReply, error)
	// Request price history and get result via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "timeframe": "D1", <br>
	//	 "from": "2022-10-01T00:00:00", <br>
	//	 "count": "10" <br>
	//	}
	RequestQuoteHistory(ctx context.Context, in *RequestQuoteHistoryRequest, opts ...grpc.CallOption) (*RequestQuoteHistoryReply, error)
	// Subscribe for order profit updates and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "type": "Client" <br>
	//	}
	SetPlacedType(ctx context.Context, in *SetPlacedTypeRequest, opts ...grpc.CallOption) (*SetPlacedTypeReply, error)
	// Check investor mode.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	IsInvestor(ctx context.Context, in *IsInvestorRequest, opts ...grpc.CallOption) (*IsInvestorReply, error)
}

type mT4Client struct {
	cc grpc.ClientConnInterface
}

func NewMT4Client(cc grpc.ClientConnInterface) MT4Client {
	return &mT4Client{cc}
}

func (c *mT4Client) AccountSummary(ctx context.Context, in *AccountSummaryRequest, opts ...grpc.CallOption) (*AccountSummaryReply, error) {
	out := new(AccountSummaryReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/AccountSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) Groups(ctx context.Context, in *GroupsRequest, opts ...grpc.CallOption) (*GroupsReply, error) {
	out := new(GroupsReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/Groups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) Quote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteReply, error) {
	out := new(QuoteReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/Quote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) OpenedOrders(ctx context.Context, in *OpenedOrdersRequest, opts ...grpc.CallOption) (*OpenedOrdersReply, error) {
	out := new(OpenedOrdersReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/OpenedOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) Symbols(ctx context.Context, in *SymbolsRequest, opts ...grpc.CallOption) (*SymbolsReply, error) {
	out := new(SymbolsReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/Symbols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) SymbolParams(ctx context.Context, in *SymbolParamsRequest, opts ...grpc.CallOption) (*SymbolParamsReply, error) {
	out := new(SymbolParamsReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/SymbolParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) ServerTimezone(ctx context.Context, in *ServerTimezoneRequest, opts ...grpc.CallOption) (*ServerTimezoneReply, error) {
	out := new(ServerTimezoneReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/ServerTimezone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) SymbolParamsMany(ctx context.Context, in *SymbolParamsManyRequest, opts ...grpc.CallOption) (*SymbolParamsManyReply, error) {
	out := new(SymbolParamsManyReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/SymbolParamsMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) OpenedOrder(ctx context.Context, in *OpenedOrderRequest, opts ...grpc.CallOption) (*OpenedOrderReply, error) {
	out := new(OpenedOrderReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/OpenedOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) OrderHistory(ctx context.Context, in *OrderHistoryRequest, opts ...grpc.CallOption) (*OrderHistoryReply, error) {
	out := new(OrderHistoryReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/OrderHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) QuoteHistory(ctx context.Context, in *QuoteHistoryRequest, opts ...grpc.CallOption) (*QuoteHistoryReply, error) {
	out := new(QuoteHistoryReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/QuoteHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) QuoteHistoryMany(ctx context.Context, in *QuoteHistoryManyRequest, opts ...grpc.CallOption) (*QuoteHistoryManyReply, error) {
	out := new(QuoteHistoryManyReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/QuoteHistoryMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) ClosedOrders(ctx context.Context, in *ClosedOrdersRequest, opts ...grpc.CallOption) (*ClosedOrdersReply, error) {
	out := new(ClosedOrdersReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/ClosedOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) RequestQuoteHistory(ctx context.Context, in *RequestQuoteHistoryRequest, opts ...grpc.CallOption) (*RequestQuoteHistoryReply, error) {
	out := new(RequestQuoteHistoryReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/RequestQuoteHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) SetPlacedType(ctx context.Context, in *SetPlacedTypeRequest, opts ...grpc.CallOption) (*SetPlacedTypeReply, error) {
	out := new(SetPlacedTypeReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/SetPlacedType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mT4Client) IsInvestor(ctx context.Context, in *IsInvestorRequest, opts ...grpc.CallOption) (*IsInvestorReply, error) {
	out := new(IsInvestorReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.MT4/IsInvestor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MT4Server is the server API for MT4 service.
// All implementations must embed UnimplementedMT4Server
// for forward compatibility
type MT4Server interface {
	// Balance, Equity, Currency, FreeMargin, Margin, MarginLevel, Profit, Leverage, Credit
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	AccountSummary(context.Context, *AccountSummaryRequest) (*AccountSummaryReply, error)
	// Full infromation about symbol groups
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	Groups(context.Context, *GroupsRequest) (*GroupsReply, error)
	// Get quote
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD" <br>
	//	}
	Quote(context.Context, *QuoteRequest) (*QuoteReply, error)
	// List of opened orders
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OpenedOrders(context.Context, *OpenedOrdersRequest) (*OpenedOrdersReply, error)
	// List of symbols.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	Symbols(context.Context, *SymbolsRequest) (*SymbolsReply, error)
	// Full infromation about symbol and his group
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD" <br>
	//	}
	SymbolParams(context.Context, *SymbolParamsRequest) (*SymbolParamsReply, error)
	// Server timezone.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	ServerTimezone(context.Context, *ServerTimezoneRequest) (*ServerTimezoneReply, error)
	// Full infromation about symbols
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SymbolParamsMany(context.Context, *SymbolParamsManyRequest) (*SymbolParamsManyReply, error)
	// List of opened orders
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0" <br>
	//	}
	OpenedOrder(context.Context, *OpenedOrderRequest) (*OpenedOrderReply, error)
	// Order history
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "from": "2022-01-01T00:00:00", <br>
	//	 "to": "2023-06-01T00:00:00" <br>
	//	}
	OrderHistory(context.Context, *OrderHistoryRequest) (*OrderHistoryReply, error)
	// Price history.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "timeframe": "D1", <br>
	//	 "from": "2022-10-01T00:00:00", <br>
	//	 "count": "10" <br>
	//	}
	QuoteHistory(context.Context, *QuoteHistoryRequest) (*QuoteHistoryReply, error)
	// Price history.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "timeframe": "D1", <br>
	//	 "from": "2022-10-01T00:00:00", <br>
	//	 "count": "10" <br>
	//	}
	QuoteHistoryMany(context.Context, *QuoteHistoryManyRequest) (*QuoteHistoryManyReply, error)
	// Last 10 orders that were closed during current session
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	ClosedOrders(context.Context, *ClosedOrdersRequest) (*ClosedOrdersReply, error)
	// Request price history and get result via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "timeframe": "D1", <br>
	//	 "from": "2022-10-01T00:00:00", <br>
	//	 "count": "10" <br>
	//	}
	RequestQuoteHistory(context.Context, *RequestQuoteHistoryRequest) (*RequestQuoteHistoryReply, error)
	// Subscribe for order profit updates and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "type": "Client" <br>
	//	}
	SetPlacedType(context.Context, *SetPlacedTypeRequest) (*SetPlacedTypeReply, error)
	// Check investor mode.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	IsInvestor(context.Context, *IsInvestorRequest) (*IsInvestorReply, error)
	mustEmbedUnimplementedMT4Server()
}

// UnimplementedMT4Server must be embedded to have forward compatible implementations.
type UnimplementedMT4Server struct {
}

func (UnimplementedMT4Server) AccountSummary(context.Context, *AccountSummaryRequest) (*AccountSummaryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountSummary not implemented")
}
func (UnimplementedMT4Server) Groups(context.Context, *GroupsRequest) (*GroupsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Groups not implemented")
}
func (UnimplementedMT4Server) Quote(context.Context, *QuoteRequest) (*QuoteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quote not implemented")
}
func (UnimplementedMT4Server) OpenedOrders(context.Context, *OpenedOrdersRequest) (*OpenedOrdersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenedOrders not implemented")
}
func (UnimplementedMT4Server) Symbols(context.Context, *SymbolsRequest) (*SymbolsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Symbols not implemented")
}
func (UnimplementedMT4Server) SymbolParams(context.Context, *SymbolParamsRequest) (*SymbolParamsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolParams not implemented")
}
func (UnimplementedMT4Server) ServerTimezone(context.Context, *ServerTimezoneRequest) (*ServerTimezoneReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerTimezone not implemented")
}
func (UnimplementedMT4Server) SymbolParamsMany(context.Context, *SymbolParamsManyRequest) (*SymbolParamsManyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolParamsMany not implemented")
}
func (UnimplementedMT4Server) OpenedOrder(context.Context, *OpenedOrderRequest) (*OpenedOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenedOrder not implemented")
}
func (UnimplementedMT4Server) OrderHistory(context.Context, *OrderHistoryRequest) (*OrderHistoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderHistory not implemented")
}
func (UnimplementedMT4Server) QuoteHistory(context.Context, *QuoteHistoryRequest) (*QuoteHistoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuoteHistory not implemented")
}
func (UnimplementedMT4Server) QuoteHistoryMany(context.Context, *QuoteHistoryManyRequest) (*QuoteHistoryManyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuoteHistoryMany not implemented")
}
func (UnimplementedMT4Server) ClosedOrders(context.Context, *ClosedOrdersRequest) (*ClosedOrdersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClosedOrders not implemented")
}
func (UnimplementedMT4Server) RequestQuoteHistory(context.Context, *RequestQuoteHistoryRequest) (*RequestQuoteHistoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestQuoteHistory not implemented")
}
func (UnimplementedMT4Server) SetPlacedType(context.Context, *SetPlacedTypeRequest) (*SetPlacedTypeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPlacedType not implemented")
}
func (UnimplementedMT4Server) IsInvestor(context.Context, *IsInvestorRequest) (*IsInvestorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInvestor not implemented")
}
func (UnimplementedMT4Server) mustEmbedUnimplementedMT4Server() {}

// UnsafeMT4Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MT4Server will
// result in compilation errors.
type UnsafeMT4Server interface {
	mustEmbedUnimplementedMT4Server()
}

func RegisterMT4Server(s grpc.ServiceRegistrar, srv MT4Server) {
	s.RegisterService(&MT4_ServiceDesc, srv)
}

func _MT4_AccountSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).AccountSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/AccountSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).AccountSummary(ctx, req.(*AccountSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_Groups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).Groups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/Groups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).Groups(ctx, req.(*GroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_Quote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).Quote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/Quote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).Quote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_OpenedOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenedOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).OpenedOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/OpenedOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).OpenedOrders(ctx, req.(*OpenedOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_Symbols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).Symbols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/Symbols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).Symbols(ctx, req.(*SymbolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_SymbolParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).SymbolParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/SymbolParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).SymbolParams(ctx, req.(*SymbolParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_ServerTimezone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerTimezoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).ServerTimezone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/ServerTimezone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).ServerTimezone(ctx, req.(*ServerTimezoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_SymbolParamsMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolParamsManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).SymbolParamsMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/SymbolParamsMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).SymbolParamsMany(ctx, req.(*SymbolParamsManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_OpenedOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenedOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).OpenedOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/OpenedOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).OpenedOrder(ctx, req.(*OpenedOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_OrderHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).OrderHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/OrderHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).OrderHistory(ctx, req.(*OrderHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_QuoteHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).QuoteHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/QuoteHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).QuoteHistory(ctx, req.(*QuoteHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_QuoteHistoryMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteHistoryManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).QuoteHistoryMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/QuoteHistoryMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).QuoteHistoryMany(ctx, req.(*QuoteHistoryManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_ClosedOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClosedOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).ClosedOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/ClosedOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).ClosedOrders(ctx, req.(*ClosedOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_RequestQuoteHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuoteHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).RequestQuoteHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/RequestQuoteHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).RequestQuoteHistory(ctx, req.(*RequestQuoteHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_SetPlacedType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPlacedTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).SetPlacedType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/SetPlacedType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).SetPlacedType(ctx, req.(*SetPlacedTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MT4_IsInvestor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsInvestorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MT4Server).IsInvestor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.MT4/IsInvestor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MT4Server).IsInvestor(ctx, req.(*IsInvestorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MT4_ServiceDesc is the grpc.ServiceDesc for MT4 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MT4_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt4grpc.MT4",
	HandlerType: (*MT4Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccountSummary",
			Handler:    _MT4_AccountSummary_Handler,
		},
		{
			MethodName: "Groups",
			Handler:    _MT4_Groups_Handler,
		},
		{
			MethodName: "Quote",
			Handler:    _MT4_Quote_Handler,
		},
		{
			MethodName: "OpenedOrders",
			Handler:    _MT4_OpenedOrders_Handler,
		},
		{
			MethodName: "Symbols",
			Handler:    _MT4_Symbols_Handler,
		},
		{
			MethodName: "SymbolParams",
			Handler:    _MT4_SymbolParams_Handler,
		},
		{
			MethodName: "ServerTimezone",
			Handler:    _MT4_ServerTimezone_Handler,
		},
		{
			MethodName: "SymbolParamsMany",
			Handler:    _MT4_SymbolParamsMany_Handler,
		},
		{
			MethodName: "OpenedOrder",
			Handler:    _MT4_OpenedOrder_Handler,
		},
		{
			MethodName: "OrderHistory",
			Handler:    _MT4_OrderHistory_Handler,
		},
		{
			MethodName: "QuoteHistory",
			Handler:    _MT4_QuoteHistory_Handler,
		},
		{
			MethodName: "QuoteHistoryMany",
			Handler:    _MT4_QuoteHistoryMany_Handler,
		},
		{
			MethodName: "ClosedOrders",
			Handler:    _MT4_ClosedOrders_Handler,
		},
		{
			MethodName: "RequestQuoteHistory",
			Handler:    _MT4_RequestQuoteHistory_Handler,
		},
		{
			MethodName: "SetPlacedType",
			Handler:    _MT4_SetPlacedType_Handler,
		},
		{
			MethodName: "IsInvestor",
			Handler:    _MT4_IsInvestor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt4.proto",
}

// ServiceClient is the client API for Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceClient interface {
	// Simple test without parameters
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error)
	// Logs for specified token
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsReply, error)
	// Logs for specified token
	// <br> [Example] <br>
	// { <br>
	//
	//	 "user": "500476959", <br>
	//	 "password": "ehj4bod" <br>
	//	}
	GetLogsByUser(ctx context.Context, in *GetLogsByUserRequest, opts ...grpc.CallOption) (*GetLogsByUserReply, error)
	// Memory snapshot
	MemorySnapshot(ctx context.Context, in *MemorySnapshotRequest, opts ...grpc.CallOption) (*MemorySnapshotReply, error)
	// Broker search by company name
	// <br> [Example] <br>
	// { <br>
	//
	//	 "company": "" <br>
	//	}
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchReply, error)
	// Return all active with connection state
	GetClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsReply, error)
	// Memory usage details
	MemoryUsage(ctx context.Context, in *MemoryUsageRequest, opts ...grpc.CallOption) (*MemoryUsageReply, error)
}

type serviceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceClient(cc grpc.ClientConnInterface) ServiceClient {
	return &serviceClient{cc}
}

func (c *serviceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error) {
	out := new(PingReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsReply, error) {
	out := new(GetLogsReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/GetLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) GetLogsByUser(ctx context.Context, in *GetLogsByUserRequest, opts ...grpc.CallOption) (*GetLogsByUserReply, error) {
	out := new(GetLogsByUserReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/GetLogsByUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) MemorySnapshot(ctx context.Context, in *MemorySnapshotRequest, opts ...grpc.CallOption) (*MemorySnapshotReply, error) {
	out := new(MemorySnapshotReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/MemorySnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchReply, error) {
	out := new(SearchReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) GetClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsReply, error) {
	out := new(GetClientsReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/GetClients", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) MemoryUsage(ctx context.Context, in *MemoryUsageRequest, opts ...grpc.CallOption) (*MemoryUsageReply, error) {
	out := new(MemoryUsageReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Service/MemoryUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceServer is the server API for Service service.
// All implementations must embed UnimplementedServiceServer
// for forward compatibility
type ServiceServer interface {
	// Simple test without parameters
	Ping(context.Context, *PingRequest) (*PingReply, error)
	// Logs for specified token
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	GetLogs(context.Context, *GetLogsRequest) (*GetLogsReply, error)
	// Logs for specified token
	// <br> [Example] <br>
	// { <br>
	//
	//	 "user": "500476959", <br>
	//	 "password": "ehj4bod" <br>
	//	}
	GetLogsByUser(context.Context, *GetLogsByUserRequest) (*GetLogsByUserReply, error)
	// Memory snapshot
	MemorySnapshot(context.Context, *MemorySnapshotRequest) (*MemorySnapshotReply, error)
	// Broker search by company name
	// <br> [Example] <br>
	// { <br>
	//
	//	 "company": "" <br>
	//	}
	Search(context.Context, *SearchRequest) (*SearchReply, error)
	// Return all active with connection state
	GetClients(context.Context, *GetClientsRequest) (*GetClientsReply, error)
	// Memory usage details
	MemoryUsage(context.Context, *MemoryUsageRequest) (*MemoryUsageReply, error)
	mustEmbedUnimplementedServiceServer()
}

// UnimplementedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceServer struct {
}

func (UnimplementedServiceServer) Ping(context.Context, *PingRequest) (*PingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedServiceServer) GetLogs(context.Context, *GetLogsRequest) (*GetLogsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedServiceServer) GetLogsByUser(context.Context, *GetLogsByUserRequest) (*GetLogsByUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogsByUser not implemented")
}
func (UnimplementedServiceServer) MemorySnapshot(context.Context, *MemorySnapshotRequest) (*MemorySnapshotReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemorySnapshot not implemented")
}
func (UnimplementedServiceServer) Search(context.Context, *SearchRequest) (*SearchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedServiceServer) GetClients(context.Context, *GetClientsRequest) (*GetClientsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClients not implemented")
}
func (UnimplementedServiceServer) MemoryUsage(context.Context, *MemoryUsageRequest) (*MemoryUsageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MemoryUsage not implemented")
}
func (UnimplementedServiceServer) mustEmbedUnimplementedServiceServer() {}

// UnsafeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServer will
// result in compilation errors.
type UnsafeServiceServer interface {
	mustEmbedUnimplementedServiceServer()
}

func RegisterServiceServer(s grpc.ServiceRegistrar, srv ServiceServer) {
	s.RegisterService(&Service_ServiceDesc, srv)
}

func _Service_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/GetLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).GetLogs(ctx, req.(*GetLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_GetLogsByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).GetLogsByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/GetLogsByUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).GetLogsByUser(ctx, req.(*GetLogsByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_MemorySnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemorySnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).MemorySnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/MemorySnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).MemorySnapshot(ctx, req.(*MemorySnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_GetClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).GetClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/GetClients",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).GetClients(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_MemoryUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).MemoryUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Service/MemoryUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).MemoryUsage(ctx, req.(*MemoryUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Service_ServiceDesc is the grpc.ServiceDesc for Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Service_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt4grpc.Service",
	HandlerType: (*ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Service_Ping_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _Service_GetLogs_Handler,
		},
		{
			MethodName: "GetLogsByUser",
			Handler:    _Service_GetLogsByUser_Handler,
		},
		{
			MethodName: "MemorySnapshot",
			Handler:    _Service_MemorySnapshot_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _Service_Search_Handler,
		},
		{
			MethodName: "GetClients",
			Handler:    _Service_GetClients_Handler,
		},
		{
			MethodName: "MemoryUsage",
			Handler:    _Service_MemoryUsage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt4.proto",
}

// SubscriptionsClient is the client API for Subscriptions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubscriptionsClient interface {
	// Subscribe symbol for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "interval": "0" <br>
	//	}
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeReply, error)
	// Subscribe symbosl for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "interval": "0" <br>
	//	}
	SubscribeMany(ctx context.Context, in *SubscribeManyRequest, opts ...grpc.CallOption) (*SubscribeManyReply, error)
	// Unsubscribe symbol for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD" <br>
	//	}
	UnSubscribe(ctx context.Context, in *UnSubscribeRequest, opts ...grpc.CallOption) (*UnSubscribeReply, error)
	// UnSubscribe symbosls for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	UnSubscribeMany(ctx context.Context, in *UnSubscribeManyRequest, opts ...grpc.CallOption) (*UnSubscribeManyReply, error)
	// Subscribe for order profit updates and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SubscribeOrderProfit(ctx context.Context, in *SubscribeOrderProfitRequest, opts ...grpc.CallOption) (*SubscribeOrderProfitReply, error)
	// Subscribe symbol for tick value updates
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "interval": "0" <br>
	//	}
	SubscribeTickValue(ctx context.Context, in *SubscribeTickValueRequest, opts ...grpc.CallOption) (*SubscribeTickValueReply, error)
	// Subscribe symbol for tick value updates
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SubscribeOrderUpdate(ctx context.Context, in *SubscribeOrderUpdateRequest, opts ...grpc.CallOption) (*SubscribeOrderUpdateReply, error)
	// Subscribe quote history
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SubscribeQuoteHistory(ctx context.Context, in *SubscribeQuoteHistoryRequest, opts ...grpc.CallOption) (*SubscribeQuoteHistoryReply, error)
}

type subscriptionsClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscriptionsClient(cc grpc.ClientConnInterface) SubscriptionsClient {
	return &subscriptionsClient{cc}
}

func (c *subscriptionsClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeReply, error) {
	out := new(SubscribeReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) SubscribeMany(ctx context.Context, in *SubscribeManyRequest, opts ...grpc.CallOption) (*SubscribeManyReply, error) {
	out := new(SubscribeManyReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/SubscribeMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) UnSubscribe(ctx context.Context, in *UnSubscribeRequest, opts ...grpc.CallOption) (*UnSubscribeReply, error) {
	out := new(UnSubscribeReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/UnSubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) UnSubscribeMany(ctx context.Context, in *UnSubscribeManyRequest, opts ...grpc.CallOption) (*UnSubscribeManyReply, error) {
	out := new(UnSubscribeManyReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/UnSubscribeMany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) SubscribeOrderProfit(ctx context.Context, in *SubscribeOrderProfitRequest, opts ...grpc.CallOption) (*SubscribeOrderProfitReply, error) {
	out := new(SubscribeOrderProfitReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/SubscribeOrderProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) SubscribeTickValue(ctx context.Context, in *SubscribeTickValueRequest, opts ...grpc.CallOption) (*SubscribeTickValueReply, error) {
	out := new(SubscribeTickValueReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/SubscribeTickValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) SubscribeOrderUpdate(ctx context.Context, in *SubscribeOrderUpdateRequest, opts ...grpc.CallOption) (*SubscribeOrderUpdateReply, error) {
	out := new(SubscribeOrderUpdateReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/SubscribeOrderUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionsClient) SubscribeQuoteHistory(ctx context.Context, in *SubscribeQuoteHistoryRequest, opts ...grpc.CallOption) (*SubscribeQuoteHistoryReply, error) {
	out := new(SubscribeQuoteHistoryReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Subscriptions/SubscribeQuoteHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionsServer is the server API for Subscriptions service.
// All implementations must embed UnimplementedSubscriptionsServer
// for forward compatibility
type SubscriptionsServer interface {
	// Subscribe symbol for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "interval": "0" <br>
	//	}
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeReply, error)
	// Subscribe symbosl for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "interval": "0" <br>
	//	}
	SubscribeMany(context.Context, *SubscribeManyRequest) (*SubscribeManyReply, error)
	// Unsubscribe symbol for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD" <br>
	//	}
	UnSubscribe(context.Context, *UnSubscribeRequest) (*UnSubscribeReply, error)
	// UnSubscribe symbosls for real time quotes and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	UnSubscribeMany(context.Context, *UnSubscribeManyRequest) (*UnSubscribeManyReply, error)
	// Subscribe for order profit updates and get results via /events socket connection
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SubscribeOrderProfit(context.Context, *SubscribeOrderProfitRequest) (*SubscribeOrderProfitReply, error)
	// Subscribe symbol for tick value updates
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "interval": "0" <br>
	//	}
	SubscribeTickValue(context.Context, *SubscribeTickValueRequest) (*SubscribeTickValueReply, error)
	// Subscribe symbol for tick value updates
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SubscribeOrderUpdate(context.Context, *SubscribeOrderUpdateRequest) (*SubscribeOrderUpdateReply, error)
	// Subscribe quote history
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	SubscribeQuoteHistory(context.Context, *SubscribeQuoteHistoryRequest) (*SubscribeQuoteHistoryReply, error)
	mustEmbedUnimplementedSubscriptionsServer()
}

// UnimplementedSubscriptionsServer must be embedded to have forward compatible implementations.
type UnimplementedSubscriptionsServer struct {
}

func (UnimplementedSubscriptionsServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedSubscriptionsServer) SubscribeMany(context.Context, *SubscribeManyRequest) (*SubscribeManyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeMany not implemented")
}
func (UnimplementedSubscriptionsServer) UnSubscribe(context.Context, *UnSubscribeRequest) (*UnSubscribeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnSubscribe not implemented")
}
func (UnimplementedSubscriptionsServer) UnSubscribeMany(context.Context, *UnSubscribeManyRequest) (*UnSubscribeManyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnSubscribeMany not implemented")
}
func (UnimplementedSubscriptionsServer) SubscribeOrderProfit(context.Context, *SubscribeOrderProfitRequest) (*SubscribeOrderProfitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeOrderProfit not implemented")
}
func (UnimplementedSubscriptionsServer) SubscribeTickValue(context.Context, *SubscribeTickValueRequest) (*SubscribeTickValueReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeTickValue not implemented")
}
func (UnimplementedSubscriptionsServer) SubscribeOrderUpdate(context.Context, *SubscribeOrderUpdateRequest) (*SubscribeOrderUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeOrderUpdate not implemented")
}
func (UnimplementedSubscriptionsServer) SubscribeQuoteHistory(context.Context, *SubscribeQuoteHistoryRequest) (*SubscribeQuoteHistoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeQuoteHistory not implemented")
}
func (UnimplementedSubscriptionsServer) mustEmbedUnimplementedSubscriptionsServer() {}

// UnsafeSubscriptionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscriptionsServer will
// result in compilation errors.
type UnsafeSubscriptionsServer interface {
	mustEmbedUnimplementedSubscriptionsServer()
}

func RegisterSubscriptionsServer(s grpc.ServiceRegistrar, srv SubscriptionsServer) {
	s.RegisterService(&Subscriptions_ServiceDesc, srv)
}

func _Subscriptions_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_SubscribeMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).SubscribeMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/SubscribeMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).SubscribeMany(ctx, req.(*SubscribeManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_UnSubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnSubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).UnSubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/UnSubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).UnSubscribe(ctx, req.(*UnSubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_UnSubscribeMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnSubscribeManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).UnSubscribeMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/UnSubscribeMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).UnSubscribeMany(ctx, req.(*UnSubscribeManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_SubscribeOrderProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeOrderProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).SubscribeOrderProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/SubscribeOrderProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).SubscribeOrderProfit(ctx, req.(*SubscribeOrderProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_SubscribeTickValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeTickValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).SubscribeTickValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/SubscribeTickValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).SubscribeTickValue(ctx, req.(*SubscribeTickValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_SubscribeOrderUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeOrderUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).SubscribeOrderUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/SubscribeOrderUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).SubscribeOrderUpdate(ctx, req.(*SubscribeOrderUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscriptions_SubscribeQuoteHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeQuoteHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionsServer).SubscribeQuoteHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Subscriptions/SubscribeQuoteHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionsServer).SubscribeQuoteHistory(ctx, req.(*SubscribeQuoteHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Subscriptions_ServiceDesc is the grpc.ServiceDesc for Subscriptions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Subscriptions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt4grpc.Subscriptions",
	HandlerType: (*SubscriptionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subscribe",
			Handler:    _Subscriptions_Subscribe_Handler,
		},
		{
			MethodName: "SubscribeMany",
			Handler:    _Subscriptions_SubscribeMany_Handler,
		},
		{
			MethodName: "UnSubscribe",
			Handler:    _Subscriptions_UnSubscribe_Handler,
		},
		{
			MethodName: "UnSubscribeMany",
			Handler:    _Subscriptions_UnSubscribeMany_Handler,
		},
		{
			MethodName: "SubscribeOrderProfit",
			Handler:    _Subscriptions_SubscribeOrderProfit_Handler,
		},
		{
			MethodName: "SubscribeTickValue",
			Handler:    _Subscriptions_SubscribeTickValue_Handler,
		},
		{
			MethodName: "SubscribeOrderUpdate",
			Handler:    _Subscriptions_SubscribeOrderUpdate_Handler,
		},
		{
			MethodName: "SubscribeQuoteHistory",
			Handler:    _Subscriptions_SubscribeQuoteHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt4.proto",
}

// TradingClient is the client API for Trading service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradingClient interface {
	// Send market or pending order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "operation": "Buy", <br>
	//	 "volume": "0.1", <br>
	//	 "price": "0", <br>
	//	 "slippage": "0", <br>
	//	 "stoploss": "0", <br>
	//	 "takeprofit": "0", <br>
	//	 "magic": "0", <br>
	//	 "placedType": "Client" <br>
	//	}
	OrderSend(ctx context.Context, in *OrderSendRequest, opts ...grpc.CallOption) (*OrderSendReply, error)
	// Modify market or pending order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0", <br>
	//	 "stoploss": "0", <br>
	//	 "takeprofit": "0", <br>
	//	 "price": "0" <br>
	//	}
	OrderModify(ctx context.Context, in *OrderModifyRequest, opts ...grpc.CallOption) (*OrderModifyReply, error)
	// Close market order with opposite market order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket1": "0", <br>
	//	 "ticket2": "0" <br>
	//	}
	OrderCloseBy(ctx context.Context, in *OrderCloseByRequest, opts ...grpc.CallOption) (*OrderCloseByReply, error)
	// Delete pending order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0" <br>
	//	}
	OrderDelete(ctx context.Context, in *OrderDeleteRequest, opts ...grpc.CallOption) (*OrderDeleteReply, error)
	// Close market order with opposite market order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0", <br>
	//	 "lots": "0", <br>
	//	 "price": "0", <br>
	//	 "slippage": "0" <br>
	//	}
	OrderClose(ctx context.Context, in *OrderCloseRequest, opts ...grpc.CallOption) (*OrderCloseReply, error)
}

type tradingClient struct {
	cc grpc.ClientConnInterface
}

func NewTradingClient(cc grpc.ClientConnInterface) TradingClient {
	return &tradingClient{cc}
}

func (c *tradingClient) OrderSend(ctx context.Context, in *OrderSendRequest, opts ...grpc.CallOption) (*OrderSendReply, error) {
	out := new(OrderSendReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Trading/OrderSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) OrderModify(ctx context.Context, in *OrderModifyRequest, opts ...grpc.CallOption) (*OrderModifyReply, error) {
	out := new(OrderModifyReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Trading/OrderModify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) OrderCloseBy(ctx context.Context, in *OrderCloseByRequest, opts ...grpc.CallOption) (*OrderCloseByReply, error) {
	out := new(OrderCloseByReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Trading/OrderCloseBy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) OrderDelete(ctx context.Context, in *OrderDeleteRequest, opts ...grpc.CallOption) (*OrderDeleteReply, error) {
	out := new(OrderDeleteReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Trading/OrderDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingClient) OrderClose(ctx context.Context, in *OrderCloseRequest, opts ...grpc.CallOption) (*OrderCloseReply, error) {
	out := new(OrderCloseReply)
	err := c.cc.Invoke(ctx, "/mt4grpc.Trading/OrderClose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingServer is the server API for Trading service.
// All implementations must embed UnimplementedTradingServer
// for forward compatibility
type TradingServer interface {
	// Send market or pending order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "symbol": "EURUSD", <br>
	//	 "operation": "Buy", <br>
	//	 "volume": "0.1", <br>
	//	 "price": "0", <br>
	//	 "slippage": "0", <br>
	//	 "stoploss": "0", <br>
	//	 "takeprofit": "0", <br>
	//	 "magic": "0", <br>
	//	 "placedType": "Client" <br>
	//	}
	OrderSend(context.Context, *OrderSendRequest) (*OrderSendReply, error)
	// Modify market or pending order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0", <br>
	//	 "stoploss": "0", <br>
	//	 "takeprofit": "0", <br>
	//	 "price": "0" <br>
	//	}
	OrderModify(context.Context, *OrderModifyRequest) (*OrderModifyReply, error)
	// Close market order with opposite market order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket1": "0", <br>
	//	 "ticket2": "0" <br>
	//	}
	OrderCloseBy(context.Context, *OrderCloseByRequest) (*OrderCloseByReply, error)
	// Delete pending order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0" <br>
	//	}
	OrderDelete(context.Context, *OrderDeleteRequest) (*OrderDeleteReply, error)
	// Close market order with opposite market order
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4", <br>
	//	 "ticket": "0", <br>
	//	 "lots": "0", <br>
	//	 "price": "0", <br>
	//	 "slippage": "0" <br>
	//	}
	OrderClose(context.Context, *OrderCloseRequest) (*OrderCloseReply, error)
	mustEmbedUnimplementedTradingServer()
}

// UnimplementedTradingServer must be embedded to have forward compatible implementations.
type UnimplementedTradingServer struct {
}

func (UnimplementedTradingServer) OrderSend(context.Context, *OrderSendRequest) (*OrderSendReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderSend not implemented")
}
func (UnimplementedTradingServer) OrderModify(context.Context, *OrderModifyRequest) (*OrderModifyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderModify not implemented")
}
func (UnimplementedTradingServer) OrderCloseBy(context.Context, *OrderCloseByRequest) (*OrderCloseByReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCloseBy not implemented")
}
func (UnimplementedTradingServer) OrderDelete(context.Context, *OrderDeleteRequest) (*OrderDeleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderDelete not implemented")
}
func (UnimplementedTradingServer) OrderClose(context.Context, *OrderCloseRequest) (*OrderCloseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderClose not implemented")
}
func (UnimplementedTradingServer) mustEmbedUnimplementedTradingServer() {}

// UnsafeTradingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradingServer will
// result in compilation errors.
type UnsafeTradingServer interface {
	mustEmbedUnimplementedTradingServer()
}

func RegisterTradingServer(s grpc.ServiceRegistrar, srv TradingServer) {
	s.RegisterService(&Trading_ServiceDesc, srv)
}

func _Trading_OrderSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).OrderSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Trading/OrderSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).OrderSend(ctx, req.(*OrderSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_OrderModify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderModifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).OrderModify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Trading/OrderModify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).OrderModify(ctx, req.(*OrderModifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_OrderCloseBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCloseByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).OrderCloseBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Trading/OrderCloseBy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).OrderCloseBy(ctx, req.(*OrderCloseByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_OrderDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).OrderDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Trading/OrderDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).OrderDelete(ctx, req.(*OrderDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trading_OrderClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingServer).OrderClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt4grpc.Trading/OrderClose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingServer).OrderClose(ctx, req.(*OrderCloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trading_ServiceDesc is the grpc.ServiceDesc for Trading service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trading_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt4grpc.Trading",
	HandlerType: (*TradingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OrderSend",
			Handler:    _Trading_OrderSend_Handler,
		},
		{
			MethodName: "OrderModify",
			Handler:    _Trading_OrderModify_Handler,
		},
		{
			MethodName: "OrderCloseBy",
			Handler:    _Trading_OrderCloseBy_Handler,
		},
		{
			MethodName: "OrderDelete",
			Handler:    _Trading_OrderDelete_Handler,
		},
		{
			MethodName: "OrderClose",
			Handler:    _Trading_OrderClose_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt4.proto",
}

// StreamsClient is the client API for Streams service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamsClient interface {
	// All trading activity on accont.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnOrderUpdate(ctx context.Context, in *OnOrderUpdateRequest, opts ...grpc.CallOption) (Streams_OnOrderUpdateClient, error)
	// Real time quotes.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnQuote(ctx context.Context, in *OnQuoteRequest, opts ...grpc.CallOption) (Streams_OnQuoteClient, error)
	// Real time quotes.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnTickValue(ctx context.Context, in *OnTickValueRequest, opts ...grpc.CallOption) (Streams_OnTickValueClient, error)
	// Orders profits updates.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnOrderProfit(ctx context.Context, in *OnOrderProfitRequest, opts ...grpc.CallOption) (Streams_OnOrderProfitClient, error)
}

type streamsClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamsClient(cc grpc.ClientConnInterface) StreamsClient {
	return &streamsClient{cc}
}

func (c *streamsClient) OnOrderUpdate(ctx context.Context, in *OnOrderUpdateRequest, opts ...grpc.CallOption) (Streams_OnOrderUpdateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Streams_ServiceDesc.Streams[0], "/mt4grpc.Streams/OnOrderUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsOnOrderUpdateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streams_OnOrderUpdateClient interface {
	Recv() (*OnOrderUpdateReply, error)
	grpc.ClientStream
}

type streamsOnOrderUpdateClient struct {
	grpc.ClientStream
}

func (x *streamsOnOrderUpdateClient) Recv() (*OnOrderUpdateReply, error) {
	m := new(OnOrderUpdateReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamsClient) OnQuote(ctx context.Context, in *OnQuoteRequest, opts ...grpc.CallOption) (Streams_OnQuoteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Streams_ServiceDesc.Streams[1], "/mt4grpc.Streams/OnQuote", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsOnQuoteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streams_OnQuoteClient interface {
	Recv() (*OnQuoteReply, error)
	grpc.ClientStream
}

type streamsOnQuoteClient struct {
	grpc.ClientStream
}

func (x *streamsOnQuoteClient) Recv() (*OnQuoteReply, error) {
	m := new(OnQuoteReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamsClient) OnTickValue(ctx context.Context, in *OnTickValueRequest, opts ...grpc.CallOption) (Streams_OnTickValueClient, error) {
	stream, err := c.cc.NewStream(ctx, &Streams_ServiceDesc.Streams[2], "/mt4grpc.Streams/OnTickValue", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsOnTickValueClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streams_OnTickValueClient interface {
	Recv() (*OnTickValueReply, error)
	grpc.ClientStream
}

type streamsOnTickValueClient struct {
	grpc.ClientStream
}

func (x *streamsOnTickValueClient) Recv() (*OnTickValueReply, error) {
	m := new(OnTickValueReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamsClient) OnOrderProfit(ctx context.Context, in *OnOrderProfitRequest, opts ...grpc.CallOption) (Streams_OnOrderProfitClient, error) {
	stream, err := c.cc.NewStream(ctx, &Streams_ServiceDesc.Streams[3], "/mt4grpc.Streams/OnOrderProfit", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamsOnOrderProfitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Streams_OnOrderProfitClient interface {
	Recv() (*OnOrderProfitReply, error)
	grpc.ClientStream
}

type streamsOnOrderProfitClient struct {
	grpc.ClientStream
}

func (x *streamsOnOrderProfitClient) Recv() (*OnOrderProfitReply, error) {
	m := new(OnOrderProfitReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamsServer is the server API for Streams service.
// All implementations must embed UnimplementedStreamsServer
// for forward compatibility
type StreamsServer interface {
	// All trading activity on accont.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnOrderUpdate(*OnOrderUpdateRequest, Streams_OnOrderUpdateServer) error
	// Real time quotes.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnQuote(*OnQuoteRequest, Streams_OnQuoteServer) error
	// Real time quotes.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnTickValue(*OnTickValueRequest, Streams_OnTickValueServer) error
	// Orders profits updates.
	// <br> [Example] <br>
	// { <br>
	//
	//	 "id": "demo-token-mt4" <br>
	//	}
	OnOrderProfit(*OnOrderProfitRequest, Streams_OnOrderProfitServer) error
	mustEmbedUnimplementedStreamsServer()
}

// UnimplementedStreamsServer must be embedded to have forward compatible implementations.
type UnimplementedStreamsServer struct {
}

func (UnimplementedStreamsServer) OnOrderUpdate(*OnOrderUpdateRequest, Streams_OnOrderUpdateServer) error {
	return status.Errorf(codes.Unimplemented, "method OnOrderUpdate not implemented")
}
func (UnimplementedStreamsServer) OnQuote(*OnQuoteRequest, Streams_OnQuoteServer) error {
	return status.Errorf(codes.Unimplemented, "method OnQuote not implemented")
}
func (UnimplementedStreamsServer) OnTickValue(*OnTickValueRequest, Streams_OnTickValueServer) error {
	return status.Errorf(codes.Unimplemented, "method OnTickValue not implemented")
}
func (UnimplementedStreamsServer) OnOrderProfit(*OnOrderProfitRequest, Streams_OnOrderProfitServer) error {
	return status.Errorf(codes.Unimplemented, "method OnOrderProfit not implemented")
}
func (UnimplementedStreamsServer) mustEmbedUnimplementedStreamsServer() {}

// UnsafeStreamsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamsServer will
// result in compilation errors.
type UnsafeStreamsServer interface {
	mustEmbedUnimplementedStreamsServer()
}

func RegisterStreamsServer(s grpc.ServiceRegistrar, srv StreamsServer) {
	s.RegisterService(&Streams_ServiceDesc, srv)
}

func _Streams_OnOrderUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnOrderUpdateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamsServer).OnOrderUpdate(m, &streamsOnOrderUpdateServer{stream})
}

type Streams_OnOrderUpdateServer interface {
	Send(*OnOrderUpdateReply) error
	grpc.ServerStream
}

type streamsOnOrderUpdateServer struct {
	grpc.ServerStream
}

func (x *streamsOnOrderUpdateServer) Send(m *OnOrderUpdateReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Streams_OnQuote_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnQuoteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamsServer).OnQuote(m, &streamsOnQuoteServer{stream})
}

type Streams_OnQuoteServer interface {
	Send(*OnQuoteReply) error
	grpc.ServerStream
}

type streamsOnQuoteServer struct {
	grpc.ServerStream
}

func (x *streamsOnQuoteServer) Send(m *OnQuoteReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Streams_OnTickValue_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnTickValueRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamsServer).OnTickValue(m, &streamsOnTickValueServer{stream})
}

type Streams_OnTickValueServer interface {
	Send(*OnTickValueReply) error
	grpc.ServerStream
}

type streamsOnTickValueServer struct {
	grpc.ServerStream
}

func (x *streamsOnTickValueServer) Send(m *OnTickValueReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Streams_OnOrderProfit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnOrderProfitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamsServer).OnOrderProfit(m, &streamsOnOrderProfitServer{stream})
}

type Streams_OnOrderProfitServer interface {
	Send(*OnOrderProfitReply) error
	grpc.ServerStream
}

type streamsOnOrderProfitServer struct {
	grpc.ServerStream
}

func (x *streamsOnOrderProfitServer) Send(m *OnOrderProfitReply) error {
	return x.ServerStream.SendMsg(m)
}

// Streams_ServiceDesc is the grpc.ServiceDesc for Streams service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Streams_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt4grpc.Streams",
	HandlerType: (*StreamsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OnOrderUpdate",
			Handler:       _Streams_OnOrderUpdate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OnQuote",
			Handler:       _Streams_OnQuote_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OnTickValue",
			Handler:       _Streams_OnTickValue_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OnOrderProfit",
			Handler:       _Streams_OnOrderProfit_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mt4.proto",
}
